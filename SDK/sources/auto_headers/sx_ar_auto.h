/*
 * Copyright (C) 2010-2021 NVIDIA CORPORATION & AFFILIATES, Ltd. ALL RIGHTS RESERVED.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
 * FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing
 * permissions and limitations under the License.
 *
 */

/*
 * [[ WARNING | AUTOMATICALLY GENERATED FILE ]]
 * ------------------------------------------------------------------------
 * This file has been generated by the script:
 *     applibs/sx_api_utils/generator/sx_header_gen.py.
 *
 * You can manually modify this file ONLY for your testing needs.
 * In all other cases manual changes in this file must be removed
 * before committing. To modify content of this file in legal way
 * use applibs/include/adb/sx_ar.adb file.
 * ------------------------------------------------------------------------
 */

#ifndef __SX_AR_AUTO_H__
#define __SX_AR_AUTO_H__

#include "sx/sdk/sx_port.h"

#define AR_PROFILE_ID_HBF  0
#define AR_PORT_RANGES_MAX 4

typedef uint8_t sx_ar_grade_t;

typedef struct sx_ar_profile_threshold {
    sx_ar_grade_t free_threshold; /**< Ports with grade <= free_thresh are considered free. Grade is in the range of 0-4 */
    sx_ar_grade_t busy_threshold; /**< Ports with grade => busy_thresh are considered busy. Grade is in the range of 0-4 */
} sx_ar_profile_threshold_t;

/* Enum specific MACRO */
#define SX_GENERATE_ENUM(ENUM, STR)   ENUM,
#define SX_GENERATE_STRING(ENUM, STR) STR,


#define FOREACH_AR_PROFILE_HANDLE(F)                                           \
    F(SX_AR_PROFILE_INVALID_E = 0, "INVALID")   /**< Invalid profile handle */ \
    F(SX_AR_PROFILE_0_E = 1,       "PROFILE_0") /**< Profile 0 handle */       \
    F(SX_AR_PROFILE_1_E = 2,       "PROFILE_1") /**< Profile 1 handle */

typedef enum sx_ar_profile_handle {
    FOREACH_AR_PROFILE_HANDLE(SX_GENERATE_ENUM)
} sx_ar_profile_handle_e;

typedef struct sx_ar_profile_key {
    sx_ar_profile_handle_e profile; /**< Profile handle */
} sx_ar_profile_key_t;

typedef struct sx_ar_shaper_attr_filter {
    boolean_t to_shaper_is_enable;   /**< Enable/Disable AR shaper_to rate */
    boolean_t from_shaper_is_enable; /**< Enable/Disable AR shaper_from rate */
} sx_ar_shaper_attr_filter_t;


#define FOREACH_AR_PROFILE_MODE(F)                                                                                                                                    \
    F(SX_AR_PROFILE_MODE_FREE_E = 0,                          "FREE")                /**< Grades-based egress port selection */                                       \
    F(SX_AR_PROFILE_MODE_TIME_BOUND_E = 1,                    "TIME_BOUND")          /**< Grades-based egress port selection with time restriction between changes */ \
    F(SX_AR_PROFILE_MODE_RANDOM_E = 2,                        "RANDOM")              /**< Random egress port selection */                                             \
    F(SX_AR_PROFILE_MODE_MIN_E = SX_AR_PROFILE_MODE_FREE_E,   "AR_PROFILE_MODE_MIN")                                                                                  \
    F(SX_AR_PROFILE_MODE_MAX_E = SX_AR_PROFILE_MODE_RANDOM_E, "AR_PROFILE_MODE_MAX")

typedef enum sx_ar_profile_mode {
    FOREACH_AR_PROFILE_MODE(SX_GENERATE_ENUM)
} sx_ar_profile_mode_e;

#define FOREACH_AR_GRADE_MODE(F)                                                \
    F(SX_AR_GRADE_MODE_PORT_E = 0, "PORT") /**< Grade is calculated per port */ \
    F(SX_AR_GRADE_MODE_TC_E = 1,   "TC")   /**< Grade is calculated per TC. Not currently supported. Will add in future */

typedef enum sx_ar_grade_mode {
    FOREACH_AR_GRADE_MODE(SX_GENERATE_ENUM)
} sx_ar_grade_mode_e;

typedef struct sx_ar_profile_attr {
    sx_ar_profile_mode_e       mode;               /**< Profile mode */
    sx_ar_profile_threshold_t  profile_threshold;  /**< Profile threshold */
    boolean_t                  only_elephant_en;   /**< AR only for elephant flows */
    sx_ar_shaper_attr_filter_t shaper_attr_filter; /**< Shaper attributes filter */
    uint32_t                   bind_time;          /**< Time bound units is 1us, the range is 5 to 1000. Ignored when mode!=SX_AR_PROFILE_MODE_TIME_BOUND */
} sx_ar_profile_attr_t;

typedef uint32_t buffer_units_t;


/**
 * Buffer < thresh_lo  will get grade 0/1 depends on link utilization
 * thresh_lo  < Buffer < thresh_med will get grade 2
 * thresh_med < Buffer < thresh_hi  will get grade 3
 * thresh_hi  < Buffer              will get grade 4
 */

typedef struct sx_ar_congestion_threshold_values {
    uint32_t congestion_thresh_lo;  /**< Congestion low threshold */
    uint32_t congestion_thresh_med; /**< Congestion medium threshold */
    uint32_t congestion_thresh_hi;  /**< Congestion high threshold */
} sx_ar_congestion_threshold_values_t;

typedef struct sx_ar_congestion_threshold_attr {
    sx_ar_congestion_threshold_values_t port_threshold; /**< Port congestion threshold */
} sx_ar_congestion_threshold_attr_t;


#define FOREACH_AR_CLASSIFIER_TYPE(F)                                                                              \
    F(SX_AR_CLASSIFIER_TYPE_DEFAULT_E = 0,      "CLASSIFIER_TYPE_DEFAULT")      /**< Classifier type is default */ \
    F(SX_AR_CLASSIFIER_TYPE_USER_DEFINED_E = 1, "CLASSIFIER_TYPE_USER_DEFINED") /**< Classifier is defined by user */

typedef enum sx_ar_classifier_type {
    FOREACH_AR_CLASSIFIER_TYPE(SX_GENERATE_ENUM)
} sx_ar_classifier_type_e;

#define FOREACH_AR_CLASSIFIER_ID(F)                                                                    \
    F(SX_AR_CLASSIFIER_INDEX_0_E = 0,                                    "INDEX_0")       /**< ID 0 */ \
    F(SX_AR_CLASSIFIER_INDEX_1_E = 1,                                    "INDEX_1")       /**< ID 1 */ \
    F(SX_AR_CLASSIFIER_INDEX_2_E = 2,                                    "INDEX_2")       /**< ID 2 */ \
    F(SX_AR_CLASSIFIER_INDEX_3_E = 3,                                    "INDEX_3")       /**< ID 3 */ \
    F(SX_AR_CLASSIFIER_INDEX_MIN_E = SX_AR_CLASSIFIER_INDEX_0_E,         "")                           \
    F(SX_AR_CLASSIFIER_INDEX_MAX_E = SX_AR_CLASSIFIER_INDEX_3_E,         "")                           \
    F(SX_AR_CLASSIFIER_INDEX_DEFAULT_E = SX_AR_CLASSIFIER_INDEX_MAX_E + 1, "INDEX_DEFAULT") /**< Default classifier */

typedef enum sx_ar_classifier_id {
    FOREACH_AR_CLASSIFIER_ID(SX_GENERATE_ENUM)
} sx_ar_classifier_id_e;

#define FOREACH_AR_CLASSIFIER_ACTION_TYPE(F)                                                                                                              \
    F(SX_AR_CLASSIFIER_ACTION_STATIC_E = 0,                               "STATIC")                   /**< Classifier action is static */                 \
    F(SX_AR_CLASSIFIER_ACTION_PROFILE0_E = 1,                             "PROFILE0")                 /**< Classifier action is according to profile 0 */ \
    F(SX_AR_CLASSIFIER_ACTION_PROFILE1_E = 2,                             "PROFILE1")                 /**< Classifier action is according to profile 1 */ \
    F(SX_AR_CLASSIFIER_ACTION_MAX_E = SX_AR_CLASSIFIER_ACTION_PROFILE1_E, "AR_CLASSIFIER_ACTION_MAX")

typedef enum sx_ar_classifier_action_type {
    FOREACH_AR_CLASSIFIER_ACTION_TYPE(SX_GENERATE_ENUM)
} sx_ar_classifier_action_type_e;

typedef struct sx_ar_classifier_action {
    sx_ar_classifier_action_type_e ar_flow_classification; /**< Classifier action type */
} sx_ar_classifier_action_t;

#define AR_CLASSIFIER_BTH_OPCODE_HIGH_SIZE 8
#define AR_CLASSIFIER_BTH_OPCODE_LOW_SIZE  32


typedef struct sx_ar_bth_opcodes {
    uint8_t bth_opcode_7_5[AR_CLASSIFIER_BTH_OPCODE_HIGH_SIZE]; /**< list of values 0-7 */
    uint8_t bth_opcode_7_5_cnt;
    uint8_t bth_opcode_4_0[AR_CLASSIFIER_BTH_OPCODE_LOW_SIZE];  /**< list of values 0-31 */
    uint8_t bth_opcode_4_0_cnt;
} sx_ar_bth_opcodes_t;


#define FOREACH_AR_CLASSIFIER_HEADER_TYPE_L3(F)                  \
    F(SX_AR_CLASSIFIER_L3_OTHERS_E = 0, "OTHERS") /**< Others */ \
    F(SX_AR_CLASSIFIER_L3_IPV4_E = 1,   "IPV4")   /**< IPv4 */   \
    F(SX_AR_CLASSIFIER_L3_IPV6_E = 2,   "IPV6")   /**< IPv6 */   \
    F(SX_AR_CLASSIFIER_L3_MPLS_E = 3,   "MPLS")   /**< MPLS */   \
    F(SX_AR_CLASSIFIER_L3_ANY_E = 4,    "ANY")    /**< Don't care */

typedef enum sx_ar_classifier_header_type_l3 {
    FOREACH_AR_CLASSIFIER_HEADER_TYPE_L3(SX_GENERATE_ENUM)
} sx_ar_classifier_header_type_l3_e;

#define FOREACH_AR_CLASSIFIER_HEADER_TYPE_L4(F)                  \
    F(SX_AR_CLASSIFIER_L4_OTHERS_E = 0, "OTHERS") /**< Others */ \
    F(SX_AR_CLASSIFIER_L4_TCP_E = 1,    "TCP")    /**< TCP */    \
    F(SX_AR_CLASSIFIER_L4_UDP_E = 2,    "UDP")    /**< UDP */    \
    F(SX_AR_CLASSIFIER_L4_ROCEv2_E = 3, "ROCEv2") /**< ROCEv2 */ \
    F(SX_AR_CLASSIFIER_L4_ANY_E = 4,    "ANY")    /**< Don't care */

typedef enum sx_ar_classifier_header_type_l4 {
    FOREACH_AR_CLASSIFIER_HEADER_TYPE_L4(SX_GENERATE_ENUM)
} sx_ar_classifier_header_type_l4_e;

#define FOREACH_AR_CLASSIFIER_BTH_HEADER_STATE(F)                                            \
    F(SX_AR_IN_BTH_HEADER_OFF_E = 0, "SX_AR_IN_BTH_HEADER_OFF") /**< AR in BTH header off */ \
    F(SX_AR_IN_BTH_HEADER_ON_E = 1,  "SX_AR_IN_BTH_HEADER_ON")  /**< AR in BTH header on */  \
    F(SX_AR_IN_BTH_HEADER_ANY_E = 2, "SX_AR_IN_BTH_HEADER_ANY") /**< AR in BTH header don't care */

typedef enum sx_ar_classifier_bth_header_state {
    FOREACH_AR_CLASSIFIER_BTH_HEADER_STATE(SX_GENERATE_ENUM)
} sx_ar_classifier_bth_header_state_e;

#define FOREACH_AR_CLASSIFIER_L4_PROTO(F)                                      \
    F(SX_AR_CLASSIFIER_L4_PROTO_ANY_E = 0,     "ANY")     /**< Always match */ \
    F(SX_AR_CLASSIFIER_L4_PROTO_UDP_E = 1,     "UDP")     /**< UDP */          \
    F(SX_AR_CLASSIFIER_L4_PROTO_TCP_E = 2,     "TCP")     /**< TCP */          \
    F(SX_AR_CLASSIFIER_L4_PROTO_TCP_UDP_E = 3, "TCP/UDP") /**< TCP/UDP */

typedef enum sx_ar_classifier_l4_proto {
    FOREACH_AR_CLASSIFIER_L4_PROTO(SX_GENERATE_ENUM)
} sx_ar_classifier_l4_proto_e;

#define FOREACH_AR_CLASSIFIER_L4_PORT(F)                                                \
    F(SX_AR_CLASSIFIER_L4_PORT_DEST_E = 0, "DESTINATION_PORT") /**< Destination port */ \
    F(SX_AR_CLASSIFIER_L4_PORT_SRC_E = 1,  "SOURCE_PORT")      /**< Source port */

typedef enum sx_ar_classifier_l4_port {
    FOREACH_AR_CLASSIFIER_L4_PORT(SX_GENERATE_ENUM)
} sx_ar_classifier_l4_port_e;

typedef struct sx_ar_classifier_l4_port_range {
    uint16_t                    port_low;  /**< Lower port range */
    uint16_t                    port_high; /**< Higher port range */
    sx_ar_classifier_l4_proto_e protocol;  /**< TCP/UDP or both */
    sx_ar_classifier_l4_port_e  port;      /**< Source/Destination port */
} sx_ar_classifier_l4_port_range_t;

typedef struct sx_ar_classifier_attr_key {
    sx_port_log_id_t                    log_ports[MAX_PHYPORT_NUM];
    uint32_t                            log_ports_cnt;
    sx_cos_priority_t                   switch_priorities[RM_API_COS_PORT_PRIO_MAX + 1];
    uint32_t                            switch_priorities_cnt;
    sx_ar_bth_opcodes_t                 bth_opcodes;
    sx_ar_bth_opcodes_t                 inner_bth_opcodes;
    sx_ar_classifier_header_type_l3_e   l3;
    sx_ar_classifier_header_type_l3_e   inner_l3;
    sx_ar_classifier_header_type_l4_e   l4;
    sx_ar_classifier_header_type_l4_e   inner_l4;
    sx_ar_classifier_bth_header_state_e bth_ar;
    sx_ar_classifier_bth_header_state_e inner_bth_ar;
    sx_ar_classifier_l4_port_range_t    port_ranges[AR_PORT_RANGES_MAX];
    uint32_t                            port_ranges_cnt;
} sx_ar_classifier_attr_key_t;

typedef struct sx_ar_classifier_attr {
    sx_ar_classifier_attr_key_t key; /**< Classifier attributes key */
} sx_ar_classifier_attr_t;

typedef struct sx_ar_link_utilization_attr {
    uint32_t link_utilization_threshold; /**< Units of 1000 bps and 200mbps granularity. Link utilization = link_utilization_threshold * 1000, Should be a multiplication of 200mbps. Default value: 70% of link speed. */
} sx_ar_link_utilization_attr_t;


/**
 * Adaptive routing shaper rate param that measures a time between consecutive flow moves. Units of 100ns
 */
typedef uint16_t sx_ar_shaper_rate_t;


/**
 * To avoid moving a large amount of flows in a short time from one output to another output two types of shapers per port are used. Measure time units of 100ns.
 */
typedef struct sx_ar_shaper_attr {
    sx_ar_shaper_rate_t shaper_rate_to;   /**< A shaper per output port for the number of flows that changed their destination to the output port */
    sx_ar_shaper_rate_t shaper_rate_from; /**< A shaper per output port for the number of flows that changed their destination from the output port */
} sx_ar_shaper_attr_t;

/**
 * Init library params.
 */
typedef struct sx_ar_init_params {
    uint32_t reserved; /**< Reserved params */
} sx_ar_init_params_t;

#endif /* __SX_AR_AUTO_H__ */
