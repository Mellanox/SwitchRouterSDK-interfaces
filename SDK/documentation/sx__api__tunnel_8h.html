<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA Ethernet Switch SDK API Guide: sdk/sx_api_tunnel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NVIDIA Ethernet Switch SDK API Guide
   &#160;<span id="projectnumber">4.5.1154</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_tunnel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__tunnel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40bc19e566d33dc03cf2e672cb18a55d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a40bc19e566d33dc03cf2e672cb18a55d">sx_api_tunnel_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:a40bc19e566d33dc03cf2e672cb18a55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa95d22b8e1b6eaa1322e49eac53a84"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#acfa95d22b8e1b6eaa1322e49eac53a84">sx_api_tunnel_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:acfa95d22b8e1b6eaa1322e49eac53a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec5c4b2f9b81ec479dad1b50d9ba52"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#aa7ec5c4b2f9b81ec479dad1b50d9ba52">sx_api_tunnel_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_attribute_t *tunnel_attr_p, sx_tunnel_id_t *tunnel_id_p)</td></tr>
<tr class="separator:aa7ec5c4b2f9b81ec479dad1b50d9ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22113f980b5750d68d351869bd87588"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#ac22113f980b5750d68d351869bd87588">sx_api_tunnel_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_attribute_t *tunnel_attr_p)</td></tr>
<tr class="separator:ac22113f980b5750d68d351869bd87588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9ad0f9d5aba9b3d67571f3d32f5acd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a5a9ad0f9d5aba9b3d67571f3d32f5acd">sx_api_tunnel_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, sx_tunnel_counter_t *counter)</td></tr>
<tr class="separator:a5a9ad0f9d5aba9b3d67571f3d32f5acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b2ae1f5bf4f1475c69302b2eb42e8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#af16b2ae1f5bf4f1475c69302b2eb42e8">sx_api_tunnel_decap_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_decap_entry_key_t *decap_key_p, const sx_tunnel_decap_entry_data_t *decap_data_p)</td></tr>
<tr class="separator:af16b2ae1f5bf4f1475c69302b2eb42e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89448d7a5bf4dfdce358d149fbd5094a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a89448d7a5bf4dfdce358d149fbd5094a">sx_api_tunnel_decap_rules_get</a> (const sx_api_handle_t handle, const sx_tunnel_decap_entry_key_t *decap_key_p, sx_tunnel_decap_entry_data_t *decap_data_p)</td></tr>
<tr class="separator:a89448d7a5bf4dfdce358d149fbd5094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ad038ffde3ed3d010d3ac13791c030"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a19ad038ffde3ed3d010d3ac13791c030">sx_api_tunnel_init_set</a> (const sx_api_handle_t handle, sx_tunnel_general_params_t *params_p)</td></tr>
<tr class="separator:a19ad038ffde3ed3d010d3ac13791c030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5441bcc9b92faf2210b9245091e9d1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a8a5441bcc9b92faf2210b9245091e9d1">sx_api_tunnel_deinit_set</a> (const sx_api_handle_t handle)</td></tr>
<tr class="separator:a8a5441bcc9b92faf2210b9245091e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0289ce12b688e179afd12b033eb310"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a1b0289ce12b688e179afd12b033eb310">sx_api_tunnel_map_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, const sx_tunnel_map_entry_t *map_entries_p, const uint32_t map_entries_cnt)</td></tr>
<tr class="separator:a1b0289ce12b688e179afd12b033eb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6753f86e8ddfdb89212f2396421d1b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#afa6753f86e8ddfdb89212f2396421d1b">sx_api_tunnel_map_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, sx_tunnel_map_entry_t map_entry_key, sx_tunnel_map_entry_t *map_entries_p, uint32_t *map_entries_cnt_p)</td></tr>
<tr class="separator:afa6753f86e8ddfdb89212f2396421d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0850ddee0e9d5de66c019d34c58298"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#afa0850ddee0e9d5de66c019d34c58298">sx_api_tunnel_ttl_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_ttl_data_t *ttl_data_p)</td></tr>
<tr class="separator:afa0850ddee0e9d5de66c019d34c58298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e78da067e72db6d6bd0d0354a164e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a051e78da067e72db6d6bd0d0354a164e">sx_api_tunnel_ttl_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_ttl_data_t *ttl_data_p)</td></tr>
<tr class="separator:a051e78da067e72db6d6bd0d0354a164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacaed82de539dde10f0f224c8481131"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#adacaed82de539dde10f0f224c8481131">sx_api_tunnel_hash_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_hash_data_t *hash_data_p)</td></tr>
<tr class="separator:adacaed82de539dde10f0f224c8481131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913cbbdda820ade6c31286205243ef3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a4913cbbdda820ade6c31286205243ef3">sx_api_tunnel_hash_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_hash_data_t *hash_data_p)</td></tr>
<tr class="separator:a4913cbbdda820ade6c31286205243ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8282a313296ef7e26c11baaa74f5e09e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a8282a313296ef7e26c11baaa74f5e09e">sx_api_tunnel_cos_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_cos_data_t *cos_data_p)</td></tr>
<tr class="separator:a8282a313296ef7e26c11baaa74f5e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ccc19db14cb9bb25d7c573942e4a80"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#af8ccc19db14cb9bb25d7c573942e4a80">sx_api_tunnel_cos_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_cos_data_t *cos_data_p)</td></tr>
<tr class="separator:af8ccc19db14cb9bb25d7c573942e4a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a57594ec83a22b4be1a5571d9a8266"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a78a57594ec83a22b4be1a5571d9a8266">sx_api_tunnel_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, const sx_tunnel_filter_t *filter_p, sx_tunnel_id_t *tunnel_id_list_p, uint32_t *tunnel_id_cnt_p)</td></tr>
<tr class="separator:a78a57594ec83a22b4be1a5571d9a8266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e88674b4e8648261dd286fff2ac20b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#ad5e88674b4e8648261dd286fff2ac20b">sx_api_tunnel_decap_rule_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_decap_entry_key_t *decap_key_p, const sx_tunnel_decap_entry_filter_t *decap_filter_p, sx_tunnel_decap_entry_key_t *decap_key_list_p, uint32_t *decap_key_cnt_p)</td></tr>
<tr class="separator:ad5e88674b4e8648261dd286fff2ac20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a40bc19e566d33dc03cf2e672cb18a55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bc19e566d33dc03cf2e672cb18a55d">&#9670;&nbsp;</a></span>sx_api_tunnel_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of TUNNEL module.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- Set verbosity of API/MODULE/BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- TUNNEL module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- TUNNEL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE when parameter exceeds range </dd></dl>

</div>
</div>
<a id="acfa95d22b8e1b6eaa1322e49eac53a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa95d22b8e1b6eaa1322e49eac53a84">&#9670;&nbsp;</a></span>sx_api_tunnel_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of TUNNEL module.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- Get verbosity of API/MODULE/BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- TUNNEL module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- TUNNEL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE when parameter exceeds range </dd></dl>

</div>
</div>
<a id="aa7ec5c4b2f9b81ec479dad1b50d9ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ec5c4b2f9b81ec479dad1b50d9ba52">&#9670;&nbsp;</a></span>sx_api_tunnel_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_attribute_t *&#160;</td>
          <td class="paramname"><em>tunnel_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_id_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to create/edit/destroy tunnels.</p>
<p>When destroying a tunnel, tunnel_attr_p is ignored. By default, tunnel is created with TTL 255.</p>
<p>QinVxLAN: After decapsulation, the configured ethertype is pushed, the desired ethertype can be set with the tunnel's attributes. For example, attributes.vxlan.decap.ethertype = 0x8100. attributes.vxlan.decap.ethertype = 0 means the default ethertype. Non-default ethertype should be previously configured with sx_api_port_vlan_ethertype_set.</p>
<p>Lazy Delete feature is supported for VxLAN tunnels. If the Lazy Delete feature is disabled and the reference counter of tunnel is 0, then the API call with DELETE command deletes the tunnel, otherwise the SDK returns SX_STATUS_RESOURCE_IN_USE. If the Lazy Delete feature is enabled and the reference counter of a tunnel is not 0, the API call with command DELETE marks a tunnel as deleted, and the SDK returns SX_STATUS_SUCCESS. Once the reference counter of a tunnel becomes 0, SDK will delete the tunnel and will generate a notification with the trap ID SX_TRAP_ID_OBJECT_DELETED_EVENT and the ID of the tunnel that was deleted.</p>
<p>Below is the list of objects that increase the reference counter of a NVE tunnel:</p><ol type="1">
<li>Each tunnel map entry.</li>
<li>Each MC RPF VIF of type SX_ROUTER_VINTERFACE_TYPE_VXLAN.</li>
<li>Each ECMP next hop of the type SX_NEXT_HOP_TYPE_TUNNEL_ENCAP.</li>
<li>Each MC next hop of the type SX_MC_NEXT_HOP_TYPE_TUNNEL_ENCAP_IP.</li>
<li>Each ACL rule with an action of the type SX_FLEX_ACL_ACTION_TUNNEL_DECAP.</li>
<li>Each ACL rule with an action of the type SX_FLEX_ACL_ACTION_NVE_TUNNEL_ENCAP.</li>
</ol>
<p>When a tunnel is deleted, SDK also flushes (deletes) all non-static tunnel FDB entries.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY/EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_attr_p</td><td>- Pointer to tunnel attributes structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tunnel_id_p</td><td>- Tunnel ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any of the input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if the api is not supported for this device </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the command is not supported by the api </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if any of the input parameters doesn't exist </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="ac22113f980b5750d68d351869bd87588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22113f980b5750d68d351869bd87588">&#9670;&nbsp;</a></span>sx_api_tunnel_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_attribute_t *&#160;</td>
          <td class="paramname"><em>tunnel_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the tunnel configuration.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tunnel_attr_p</td><td>- Pointer to tunnel attributes structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a5a9ad0f9d5aba9b3d67571f3d32f5acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9ad0f9d5aba9b3d67571f3d32f5acd">&#9670;&nbsp;</a></span>sx_api_tunnel_counter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_counter_t *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets/clears tunnel counters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>- Pointer to tunnel counters structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="af16b2ae1f5bf4f1475c69302b2eb42e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b2ae1f5bf4f1475c69302b2eb42e8">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rules_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_data_t *&#160;</td>
          <td class="paramname"><em>decap_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage rules in the tunnel decap table. The decap table is used to terminate encapsulated packets. The decap key provides packet matching mechanism and each key is mapped to one tunnel.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY/EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>- Decap key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_data_p</td><td>- Decap data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if any input parameter does not exist </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if key is already used for another tunnel </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is not initialized </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter exceeds the valid range </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a89448d7a5bf4dfdce358d149fbd5094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89448d7a5bf4dfdce358d149fbd5094a">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rules_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_decap_entry_data_t *&#160;</td>
          <td class="paramname"><em>decap_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get decap rules from the decap table.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>- Key to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decap_data_p</td><td>- Data associated with key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if key does not exist </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a19ad038ffde3ed3d010d3ac13791c030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ad038ffde3ed3d010d3ac13791c030">&#9670;&nbsp;</a></span>sx_api_tunnel_init_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_general_params_t *&#160;</td>
          <td class="paramname"><em>params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to initialize tunneling module.</p>
<p>Note: Correct parsing depth should be set using sx_api_port_parsing_depth_set API for tunneling usage scenarios.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_p</td><td>- Pointer to general params structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_NO_RESOURCES if sufficient resources are not available for tunneling </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a8a5441bcc9b92faf2210b9245091e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5441bcc9b92faf2210b9245091e9d1">&#9670;&nbsp;</a></span>sx_api_tunnel_deinit_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to de-initialize the tunneling module.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a1b0289ce12b688e179afd12b033eb310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0289ce12b688e179afd12b033eb310">&#9670;&nbsp;</a></span>sx_api_tunnel_map_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_map_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_map_entry_t *&#160;</td>
          <td class="paramname"><em>map_entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>map_entries_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage the mapping between tunnel and bridge/VLAN. With the DELETE_ALL command, the map_entries_p parameter is ignored.</p>
<p>The Lazy delete feature is supported for VxLAN tunnel mappings. If Lazy Delete feature is disabled and the reference counter of the tunnel mapping is 0, then the API call with command DELETE deletes a tunnel mapping, otherwise the SDK returns SX_STATUS_RESOURCE_IN_USE.</p>
<p>If the Lazy Delete feature is enabled and the reference counter of the tunnel mapping is not 0, then the API call with command DELETE marks a tunnel mapping as deleted, and SDK returns SX_STATUS_SUCCESS. Once the reference counter of the tunnel mapping becomes 0, SDK will delete the tunnel mapping, unbind DECAP, ENCAP UC and ENCAP MC flow counters if they are bound and will generate a notification with the trap ID (SX_TRAP_ID_OBJECT_DELETED_EVENT) and the copy of tunnel mapping that was deleted. The NOS should monitor delete notification events in order to delete the counter resource. when trying to re-create a tunnel map entry before a notification is received, the SDK returns error SX_STATUS_RESOURCE_IN_USE.</p>
<p>Given below is the list of objects that increases the reference counter of a tunnel map entry:</p><ol type="1">
<li>A static tunnel UC FDB entry.</li>
<li>A MC FDB entry (if MC container has a tunnel next hop).</li>
<li>Each tunnel flood vector that was bound to a FID with sx_api_fdb_flood_set.</li>
<li>Each ACL rule with an action of the type SX_FLEX_ACL_ACTION_NVE_MC_TUNNEL_ENCAP (if MC container has a tunnel next hop).</li>
</ol>
<p>When a tunnel mapping is deleted, SDK also flushes (deletes) all relevant non-static tunnel FDB entries.</p>
<p>The map_entries_cnt parameter is limited by TUNNEL_MAP_ENTRIES_SET_MAX_NUM.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entries_p</td><td>- Array of map entries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entries_cnt</td><td>- Amount of entries in map_entries_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel does not exist </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if tunnel and bridge/VLAN are already bound </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the command is unsupported in this API </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE when trying to delete more maps than configured for the tunnel </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE when trying to re-create a tunnel map entry that is marked as deleted </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="afa6753f86e8ddfdb89212f2396421d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6753f86e8ddfdb89212f2396421d1b">&#9670;&nbsp;</a></span>sx_api_tunnel_map_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_map_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_map_entry_t&#160;</td>
          <td class="paramname"><em>map_entry_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_map_entry_t *&#160;</td>
          <td class="paramname"><em>map_entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>map_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the mapping information between tunnel and bridge/VLAN. This function supports the below commands in the order mentioned below.</p>
<p>GET_FIRST gets a list of first n&lt;=1000 map entries of specified tunnel ID. GETNEXT gets a list of n&lt;=1000 next map entries whose value larger than the given map_entry_key of specified tunnel ID.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_key</td><td>- Map entry (as a key to get next entries) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_entries_p</td><td>- Array of map entries </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map_entries_cnt_p</td><td>- Amount of entries in map_entries_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="afa0850ddee0e9d5de66c019d34c58298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0850ddee0e9d5de66c019d34c58298">&#9670;&nbsp;</a></span>sx_api_tunnel_ttl_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_ttl_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_ttl_data_t *&#160;</td>
          <td class="paramname"><em>ttl_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the tunnel TTL parameters.</p>
<p>Note for Spectrum devices:</p><ol type="1">
<li>TTL behavior and values are shared between all tunnels of same type.</li>
<li>IPinIP tunnels support TTL_CMD_SET and TTL_CMD_COPY in the encap direction (default value is TTL_CMD_COPY).</li>
<li>NVE tunnels support TTL_CMD_SET in the encap direction (default TTL value is 255).</li>
</ol>
<p>Note for Spectrum-2 and above:</p><ol type="1">
<li>IPinIP tunnels support only TTL_CMD_SET &amp; TTL_CMD_COPY commands.</li>
<li>IPinIP tunnels only support configuring TTL command in encap direction.</li>
<li>NVE tunnels support TTL_CMD_SET, TTL_CMD_COPY in Encap direction.</li>
<li>NVE tunnels support TTL_CMD_PRESERVE_E, TTL_CMD_COPY, TTL_CMD_MINIMUM in decap direction (default is PRESERVE).</li>
<li>For Symmetric tunnels, the TTL behavior must be set separately for encap and decap directions.</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl_data_p</td><td>- Pointer to tunnel ttl data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a051e78da067e72db6d6bd0d0354a164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051e78da067e72db6d6bd0d0354a164e">&#9670;&nbsp;</a></span>sx_api_tunnel_ttl_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_ttl_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_ttl_data_t *&#160;</td>
          <td class="paramname"><em>ttl_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get the tunnel TTL parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ttl_data_p</td><td>- Pointer to tunnel TTL data (set direction field to get configuration)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="adacaed82de539dde10f0f224c8481131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacaed82de539dde10f0f224c8481131">&#9670;&nbsp;</a></span>sx_api_tunnel_hash_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_hash_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_hash_data_t *&#160;</td>
          <td class="paramname"><em>hash_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the tunnel hash parameters.</p>
<p>Note for Spectrum:</p><ol type="1">
<li>Hash parameters are shared between all tunnels of the same type.</li>
<li>IPinIP tunnels support setting an IPV6_FLOW_LABEL (default value is 0).</li>
<li>NVE tunnels support setting a UDP_SPORT (default value is 0).</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_data_p</td><td>- Pointer to tunnel hash data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a4913cbbdda820ade6c31286205243ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4913cbbdda820ade6c31286205243ef3">&#9670;&nbsp;</a></span>sx_api_tunnel_hash_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_hash_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_hash_data_t *&#160;</td>
          <td class="paramname"><em>hash_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get the tunnel hash parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_data_p</td><td>- Pointer to tunnel hash data (hash_field_type should be set for retrieving the correct configuration)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a8282a313296ef7e26c11baaa74f5e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8282a313296ef7e26c11baaa74f5e09e">&#9670;&nbsp;</a></span>sx_api_tunnel_cos_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_cos_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_cos_data_t *&#160;</td>
          <td class="paramname"><em>cos_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the CoS attributes of tunnels. CoS behaviour applies to all tunnels of a given type. Changes applied to one tunnel will change the CoS behaviour of all tunnels of same type. The API configures QoS parameters for encapsulation and decapsulation flow separately based on value in cos_data_p-&gt;param_type.</p>
<p>Below are the parameters that can be configured:</p>
<ol type="1">
<li>cos_data_p-&gt;update_priority_color: Packet switch priority and color when it is not preserved.</li>
<li>cos_data_p-&gt;prio_color: New switch priority and color for the packet when cos_data_p-&gt;update_priority_color is set to TRUE.</li>
<li>cos_data_p-&gt;dsc_rewrite: Action for DSCP rewrite (i.e., disabled, enabled or preserved to a DSCP value that was set on packet ingress port). cos_data_p-&gt;dscp_action: If DSCP rewrite is disabled, then DSCP value is dependent on dscp_action The DSCP value on encap can be copied from inner header or set from cos_data_p-&gt;dscp_value The DSCP value on decap can be copied from outer or preserved When dscp_action is COPY and if there is no IP header, then the value from cos_data_p-&gt;dscp_value is used.</li>
<li>ECN mapping on encapsulation or decapsulation.</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cos_data_p</td><td>- Pointer to CoS data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device or tunnel type/direction </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel does not exist </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="af8ccc19db14cb9bb25d7c573942e4a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ccc19db14cb9bb25d7c573942e4a80">&#9670;&nbsp;</a></span>sx_api_tunnel_cos_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_cos_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_cos_data_t *&#160;</td>
          <td class="paramname"><em>cos_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to retrieve CoS data. CoS data retrieval for ENCAP or DECAP direction can be controlled by cos_data_p-&gt;param_type.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel</td><td>id - Tunnel ID </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cos_data_p - Pointer to CoS data (by CoS param type ENCAP or DECAP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if API is not supported for this device or tunnel type/direction </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel does not exist </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a78a57594ec83a22b4be1a5571d9a8266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a57594ec83a22b4be1a5571d9a8266">&#9670;&nbsp;</a></span>sx_api_tunnel_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_id_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves a list of one or more Tunnel IDs. The following use case scenarios apply with different input parameters. X = don't-care. 1) cmd = SX_ACCESS_CMD_GET, tunnel_id = X, filter = valid/invalid, tunnel_id_list = X, tunnel_id_cnt = 0: In this case, the API will return the total number of tunnel IDs filtered by the filter parameter, if present.</p>
<p>2) cmd = SX_ACCESS_CMD_GET, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt = 1: In this case, the API will check if the specified tunnel_id exists AND it matches the filter, if present. If it does, the tunnel ID will be returned in the tunnel_id_list along with a tunnel_id_cnt of 1. If the tunnel ID does not exist, an empty list will be returned with tunnel_id_cnt = 0. A non-NULL tunnel_id_list pointer must be provided in this case.</p>
<p>3) cmd = SX_ACCESS_CMD_GET, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt &gt; 1: A tunnel_id_cnt &gt; 1 will be treated as a tunnel_id_cnt of 1 and the behavior will be same as the previous GET use cases.</p>
<p>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, tunnel_id = X, filter = X, tunnel_id_list = NULL, tunnel_id_cnt = 0: A zero tunnel_id_cnt and an empty tunnel_id_list will be returned.</p>
<p>5) cmd = SX_ACCESS_CMD_GET_FIRST, tunnel_id = X, tunnel_id_list = valid, filter = valid/invalid, tunnel_id_cnt &gt; 0: In this case, the API will return the first tunnel_id_cnt tunnel IDs starting from the head of the database AND match the filter, if present. The total number of elements fetched will be returned as tunnel_id_cnt. The input tunnel ID is ignored, in this case. A non-NULL tunnel_id_list pointer must be provided, in this case.</p>
<p>6) cmd = SX_ACCESS_CMD_GETNEXT, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt &gt; 0: In this case, the API will return the next set of tunnel IDs which matches the filter if present starting from the next tunnel ID after the specified tunnel ID. The total number of elements fetched will be returned as the tunnel_id_cnt. If no valid next tunnel ID exists in the database, an empty list will be returned. A non-NULL tunnel_id_list pointer must be provided, in this case.</p>
<p>Two type of filter can be used: 1) sx_tunnel_type_e: It must exactly match the type defined for the tunnels. 2) sx_tunnel_direction_e: If tunnel direction is SX_TUNNEL_DIRECTION_SYMMETRIC, it will match any direction (ENCAP/DECAP/SYMMETRIC) of the filter, otherwise, it will only match the same direction of the filter.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- Specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tunnel_id_list_p</td><td>- Return list of tunnel IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tunnel_id_cnt_p</td><td>- [in] number of tunnel IDs to get/[out] number of tunnel IDs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED for tunnel module uninitialized </dd></dl>

</div>
</div>
<a id="ad5e88674b4e8648261dd286fff2ac20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e88674b4e8648261dd286fff2ac20b">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rule_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rule_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_filter_t *&#160;</td>
          <td class="paramname"><em>decap_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>decap_key_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to retrieve the count or a list of one or more Tunnel Decap Rules. The rules are essentially the Keys that the rules match on. The rule's attributes (actions) can then be read using the sx_api_tunnel_decap_rules_get API for each key. Using the filter param, the return list can be refined. The following filters are supported: 1) sx_tunnel_type_e: Only returns the keys that match the tunnel type. 2) sx_tunnel_id: Only returns the keys that match the tunnel ID.</p>
<p>The following use case scenarios apply with different input parameters. X = don't-care.</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, key = X, Filter = X, decap_key_list = X, Count=0: In this case, the API will return the total number of decap rules in the internal database.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, key = valid/invalid, Filter = X, decap_key_list = Valid, Count = 1: In this case, the API will check if the specified key exists. If it does the key will be returned in the decap_key_list along with a count of 1. If the key does not exist an empty list will be returned with count = 0.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid, decap_key_list is Valid, Count=1: In this case, the API will check if the specified key exists. If it does exist, it will check it against the filter parameter. If the filter matches, then the key will be returned in the decap_key_list along with a count of 1. If the key does not exist or the filter does not match, an empty list will be returned with count = 0.</li>
<li>4) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid/invalid,decap_key_list is Valid, Count &gt; 1: A count &gt;1 will be treated as a count of 1 and the behavior will be same as earlier GET use cases.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, key = X, Filter = X, decap_key_list = Null, Count =0: For either SX_ACCESS_CMD_GET_FIRST or SX_ACCESS_CMD_GETNEXT, a zero count will return an empty list.</li>
<li><p class="startli">6) cmd = SX_ACCESS_CMD_GET_FIRST, key = X, Filter = valid/invalid, decap_key_list = Valid, Count &gt; 0: In this case, the API will return the first count decap key entries starting from the head of the database. The total elements fetched will be returned as the return count.</p>
<p class="startli">Note: Return count may be less than or equal to the requested count. The key is dont-care. If a filter is specified, only those decap key entries that match the filter will be returned. A non-Null return decap_key_list pointer must be provided.</p>
</li>
<li><p class="startli">7) cmd = SX_ACCESS_CMD_GETNEXT, key = valid/invalid, Filter = valid/invalid, decap_key_list = Valid, Count &gt; 0: In this case, the API will return the next set of decap key entries starting from the next valid decap key entry after the specified key. The total elements fetched will be returned as the return count. If a filter is specified, then only those decap key entries that match the filter will be returned.</p>
<p class="startli">Note: Return count may be less than or equal to the requested count. If no valid next decap key entry exists in the database (key = end of list, or invalid key specified, or key too large), an empty list will be returned.</p>
</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>- Specify a Tunnel decap entry key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_filter_p</td><td>- Specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decap_key_list_p</td><td>- Return list of decap key entries </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decap_key_cnt_p</td><td>- [in] number of decap keys to read/[out] number of decap keys returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if an unsupported command is passed </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if key does not exist </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED if the database was not initialized </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 28 2021 19:04:58 for NVIDIA Ethernet Switch SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
