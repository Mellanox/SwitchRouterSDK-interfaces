<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA Ethernet Switch SDK API Guide: sdk/sx_api_bulk_counter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NVIDIA Ethernet Switch SDK API Guide
   &#160;<span id="projectnumber">4.5.3196</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_bulk_counter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__bulk__counter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0efa0de329413d231ca7c79568b942cc"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#a0efa0de329413d231ca7c79568b942cc">sx_api_bulk_counter_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:a0efa0de329413d231ca7c79568b942cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda47ec184a8b34b0023a30f58770e11"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#aeda47ec184a8b34b0023a30f58770e11">sx_api_bulk_counter_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:aeda47ec184a8b34b0023a30f58770e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96068ea7142761ce156fd1c8ab51faf4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#a96068ea7142761ce156fd1c8ab51faf4">sx_api_bulk_counter_buffer_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bulk_cntr_buffer_key_t *key_p, sx_bulk_cntr_buffer_t *buffer_p)</td></tr>
<tr class="separator:a96068ea7142761ce156fd1c8ab51faf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6dbab88535de0970d0d507aeab5c8b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#adb6dbab88535de0970d0d507aeab5c8b">sx_api_bulk_counter_transaction_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bulk_cntr_buffer_t *buffer_p)</td></tr>
<tr class="separator:adb6dbab88535de0970d0d507aeab5c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d664a825b59434d5d51d00668ec9a3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#a65d664a825b59434d5d51d00668ec9a3">sx_api_bulk_counter_transaction_get</a> (const sx_api_handle_t handle, const sx_bulk_cntr_read_key_t *key_p, const sx_bulk_cntr_buffer_t *buffer_p, sx_bulk_cntr_data_t *counter_data_p)</td></tr>
<tr class="separator:a65d664a825b59434d5d51d00668ec9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58d1b7290c1575b5a3265fd4f4eefe"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bulk__counter_8h.html#aad58d1b7290c1575b5a3265fd4f4eefe">sx_api_bulk_counter_refresh_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bulk_cntr_refresh_attr_t *counter_refresh_attr_p)</td></tr>
<tr class="separator:aad58d1b7290c1575b5a3265fd4f4eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0efa0de329413d231ca7c79568b942cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efa0de329413d231ca7c79568b942cc">&#9670;&nbsp;</a></span>sx_api_bulk_counter_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the log verbosity level of BULK COUNTER module.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3, Spectrum4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API/MODULE/BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- BULK COUNTER module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- BULK COUNTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completed successfully SX_STATUS_PARAM_ERROR Any input parameters is invalid SX_STATUS_ERROR General error </dd></dl>

</div>
</div>
<a id="aeda47ec184a8b34b0023a30f58770e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda47ec184a8b34b0023a30f58770e11">&#9670;&nbsp;</a></span>sx_api_bulk_counter_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the log verbosity level of BULK COUNTER module.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3, Spectrum4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API/MODULE/BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- BULK COUNTER module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- BULK COUNTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completed successfully SX_STATUS_PARAM_ERROR Any input parameters is invalid SX_STATUS_ERROR General error </dd></dl>

</div>
</div>
<a id="a96068ea7142761ce156fd1c8ab51faf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96068ea7142761ce156fd1c8ab51faf4">&#9670;&nbsp;</a></span>sx_api_bulk_counter_buffer_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_buffer_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bulk_cntr_buffer_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bulk_cntr_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API allocates or frees a buffer of an asynchronous bulk-counter-read operation. Notes:</p><ol type="1">
<li>Buffer is bound to key. An operation with a different key requires a new buffer.</li>
<li>Buffer may be reused on multiple operations of <a class="el" href="sx__api__bulk__counter_8h.html#adb6dbab88535de0970d0d507aeab5c8b">sx_api_bulk_counter_transaction_set()</a>.</li>
<li>Buffer operation must be completed or canceled before this function is called with SX_ACCESS_CMD_DESTROY command.</li>
<li>A user cookie can be provided in buffer_p, so it can be used later to identify the event. So that the bulk counter done event can be registered and received in different process from the process where bulk counter buffer was created.</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE to allocate buffer DESTROY to free buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- Bulk-counter desired counters: For port counters: list of logical port ID, list of priority IDs, list of TC IDs, list of priority groups. For flow counters: range of flow counter IDs. For elephant detected flows: a list of logical port IDs. When cmd is DESTROY, key is ignored and can be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer_p</td><td>- On CREATE, returned allocated buffer to be used by other APIs. On DESTROY, the buffer to deallocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completed successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL Parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR Parameter error </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED Invalid command </dd>
<dd>
SX_STATUS_NO_MEMORY No free memory </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE Buffer operation is running </dd>
<dd>
SX_STATUS_ERROR Operation failed </dd></dl>

</div>
</div>
<a id="adb6dbab88535de0970d0d507aeab5c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6dbab88535de0970d0d507aeab5c8b">&#9670;&nbsp;</a></span>sx_api_bulk_counter_transaction_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_transaction_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bulk_cntr_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API initiates or cancels an asynchronous bulk-counter-read operation.</p>
<p>READ reads a set of counters. READ_CLEAR reads and clears a set of counters. Not supported for shared buffer type snapshot counter. READ_FLUSH flushes and reads a set of counters (supported only for SX_BULK_CNTR_KEY_TYPE_FLOW_E). READ_CLEAR_FLUSH flushes, reads, and clears a set of counters (supported only for SX_BULK_CNTR_KEY_TYPE_FLOW_E). DISABLE cancels an active operation.</p>
<p>Note: In "Normal" operation the SDK reads immediate value of the counter that can be different from its final value. "Flush" operation ensures that all device subsystems clear their cached values and final counter value is updated. Note: After initiating the operation, an SX_BULK_READ_DONE event is sent and then API <a class="el" href="sx__api__bulk__counter_8h.html#a65d664a825b59434d5d51d00668ec9a3">sx_api_bulk_counter_transaction_get()</a> should be used. Until SX_BULK_READ_DONE event is received, buffer cannot be used with API <a class="el" href="sx__api__bulk__counter_8h.html#a65d664a825b59434d5d51d00668ec9a3">sx_api_bulk_counter_transaction_get()</a>. And to identify the event is what's expected by user, user should compare the buffer id in event info with the one in buffer_p, cookie should be compared too if user provided it in API <a class="el" href="sx__api__bulk__counter_8h.html#a96068ea7142761ce156fd1c8ab51faf4">sx_api_bulk_counter_buffer_set()</a>. Note: When initiating LAG port bulk-counter-read, its members are determined on operation initiation. Any change to the LAG port or to its members during the operation will not be reflected when reading the LAG counters upon operation completion. Note: elephant-detected-flow-read does not support LAG ports. Note: shared buffer key with type SX_BULK_CNTR_SHARED_BUFFER_SNAPSHOT_E should be used after calling the API sx_api_cos_sb_snapshot_action_set with action SX_SB_SNAPSHOT_ACTION_TAKE_E. Note: Upon disable, the buffer cannot be used on another operation or freed until the SW_BULK_READ_DONE event is received. Note: Up to two transactions are allowed in parallel by the system: a. 2 x Port_Counters. b. Any combination of two different bulk counter types. c. The refresh transaction (consumed by calling sx_api_bulk_counter_refresh_set) and any of the bulk counter types. d. 2 x SX_BULK_CNTR_KEY_TYPE_FLOW_E only if one of transactions is started for accumulated (SX_FLOW_COUNTER_TYPE_ACCUMULATED) counters and the second one for any other type of flow counters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3, Spectrum4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR/READ_FLUSH/READ_CLEAR_FLUSH/DISABLE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_p</td><td>- Valid buffer which was allocated by sx_api_bulk_buffer_set().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completed successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if cmd value is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is not valid </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if there is another operation with same type in-flight </dd>
<dd>
SX_STATUS_ERROR if operation completes with failure </dd></dl>

</div>
</div>
<a id="a65d664a825b59434d5d51d00668ec9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d664a825b59434d5d51d00668ec9a3">&#9670;&nbsp;</a></span>sx_api_bulk_counter_transaction_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_transaction_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bulk_cntr_read_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bulk_cntr_buffer_t *&#160;</td>
          <td class="paramname"><em>buffer_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bulk_cntr_data_t *&#160;</td>
          <td class="paramname"><em>counter_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API reads a single counter from a bulk-counter-read buffer.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3, Spectrum4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- For port counter: Logical port ID, counter group, TC (optional), priority (optional), priority-group (optional) For flow counter: Counter ID For elephant detected flows: Logical port ID, flow ID (optional). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_p</td><td>- Valid buffer which was allocated by API sx_api_bulk_buffer_set() </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_data_p</td><td>- Requested counter data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completed successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL Parameter is NULL </dd>
<dd>
SX_STATUS_PARTIALLY_COMPLETE Transaction is in progress </dd>
<dd>
SX_STATUS_ERROR Operation failure </dd></dl>

</div>
</div>
<a id="aad58d1b7290c1575b5a3265fd4f4eefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58d1b7290c1575b5a3265fd4f4eefe">&#9670;&nbsp;</a></span>sx_api_bulk_counter_refresh_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bulk_counter_refresh_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bulk_cntr_refresh_attr_t *&#160;</td>
          <td class="paramname"><em>counter_refresh_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API triggers the refresh of all accumulated (SX_FLOW_COUNTER_TYPE_ACCUMULATED) counters.</p>
<p>Note: While the refreshing is not mandatory to read the values of accumulated counters, but if the up-to-date values are needed, then the refresh API should be called before reading. The refresh is an asynchronous operation. Once the refresh is done, SDK will generate an SX_TRAP_ID_BULK_REFRESH_COUNTER_DONE_EVENT event with a copy of attributes passed to the refresh API. Once the event is received, the user can read and get fresh values of accumulated counters.</p>
<p>A user cookie can be provided as a part of the refresh attributes, later it can be used to identify the refresh done event. So that the refresh done event can be registered and received in a different process from the process where the refresh API was called.</p>
<p>Only one refresh can be active. Until a REFRESH_COUNTER_DONE_EVENT event is received, the user should not start another refresh, otherwise, SDK will return an error.</p>
<p>The refresh also requires a free bulk counter transaction. For more details about transactions, please see the description of sx_api_bulk_counter_transaction_set.</p>
<p>Supported devices: Spectrum2, Spectrum3, Spectrum4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_refresh_attr_p</td><td>- Refresh attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS Operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL Refresh attributes pointer is not initialized </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE Either the refresh is already in progress or there is no available bulk counter transaction. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED Command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE Called invalid handle </dd>
<dd>
SX_STATUS_ERROR General error happened </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2022 07:56:31 for NVIDIA Ethernet Switch SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
