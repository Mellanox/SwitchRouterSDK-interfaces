<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_fdb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.3.2104</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_fdb.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__fdb_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa402a02c1b476045b0bdbfaf4d9e466f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa402a02c1b476045b0bdbfaf4d9e466f">sx_api_fdb_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:aa402a02c1b476045b0bdbfaf4d9e466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69328504a7116dc2db6b42b18b13b16"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af69328504a7116dc2db6b42b18b13b16">sx_api_fdb_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:af69328504a7116dc2db6b42b18b13b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac719da53d4e58dc48ffc21dfce3460"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#acac719da53d4e58dc48ffc21dfce3460">sx_api_fdb_age_time_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)</td></tr>
<tr class="separator:acac719da53d4e58dc48ffc21dfce3460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4396ebb8d79d5757b3f2df8b4ff3dd51"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a4396ebb8d79d5757b3f2df8b4ff3dd51">sx_api_fdb_age_time_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)</td></tr>
<tr class="separator:a4396ebb8d79d5757b3f2df8b4ff3dd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c85bf694d723fc41318b9f41f801e8a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0c85bf694d723fc41318b9f41f801e8a">sx_api_fdb_poll_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a0c85bf694d723fc41318b9f41f801e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc878a321456849b437245a3889fa2d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0fc878a321456849b437245a3889fa2d">sx_api_fdb_polling_interval_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)</td></tr>
<tr class="separator:a0fc878a321456849b437245a3889fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cad0c84e98f74c17ff84e111689b3b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a53cad0c84e98f74c17ff84e111689b3b">sx_api_fdb_polling_interval_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_polling_interval_t *interval)</td></tr>
<tr class="separator:a53cad0c84e98f74c17ff84e111689b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c7cb7c07a29ccba6f1bd5c56fc723"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a463c7cb7c07a29ccba6f1bd5c56fc723">sx_api_fdb_uc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:a463c7cb7c07a29ccba6f1bd5c56fc723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d08fd9a8c2e68d0857b5ae986b5cf5"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab9d08fd9a8c2e68d0857b5ae986b5cf5">sx_api_fdb_uc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:ab9d08fd9a8c2e68d0857b5ae986b5cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216c40f7212a34ff4f48cdd514b7142"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa216c40f7212a34ff4f48cdd514b7142">sx_api_fdb_uc_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:aa216c40f7212a34ff4f48cdd514b7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844669ce5b39ebd0c54403b2ef31207"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ac844669ce5b39ebd0c54403b2ef31207">sx_api_fdb_uc_port_count_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:ac844669ce5b39ebd0c54403b2ef31207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e069db7cd02240336f1ddd556e507"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3c5e069db7cd02240336f1ddd556e507">sx_api_fdb_uc_fid_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:a3c5e069db7cd02240336f1ddd556e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780abaea19956b6bd7a6738e81e5867"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7780abaea19956b6bd7a6738e81e5867">sx_api_fdb_uc_limit_port_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)</td></tr>
<tr class="separator:a7780abaea19956b6bd7a6738e81e5867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8649abe905403e7facd2edcad0f896a1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8649abe905403e7facd2edcad0f896a1">sx_api_fdb_uc_limit_port_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)</td></tr>
<tr class="separator:a8649abe905403e7facd2edcad0f896a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e82f33acfac26987e66dd53dee91c38"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8e82f33acfac26987e66dd53dee91c38">sx_api_fdb_uc_limit_fid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const uint32_t limit)</td></tr>
<tr class="separator:a8e82f33acfac26987e66dd53dee91c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760a24322ae990cad9789b7a579053db"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a760a24322ae990cad9789b7a579053db">sx_api_fdb_uc_limit_fid_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *limit_p)</td></tr>
<tr class="separator:a760a24322ae990cad9789b7a579053db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5444b9e90b307936d49fe0c70232cc9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab5444b9e90b307936d49fe0c70232cc9">sx_api_fdb_mc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr class="separator:ab5444b9e90b307936d49fe0c70232cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3640c0c7f4b5fb0112a6342872835131"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3640c0c7f4b5fb0112a6342872835131">sx_api_fdb_mc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr class="separator:a3640c0c7f4b5fb0112a6342872835131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfd50615d6d2455cec6ed2bb3305430"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3bfd50615d6d2455cec6ed2bb3305430">sx_api_fdb_mc_mac_addr_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fdb_mc_mac_key_t *key_p, const sx_fdb_mc_mac_filter_t *filter_p, sx_fdb_mc_mac_key_t *key_list_p, uint32_t *key_cnt_p)</td></tr>
<tr class="separator:a3bfd50615d6d2455cec6ed2bb3305430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d816e7ed1c5915fb626d016831516a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a03d816e7ed1c5915fb626d016831516a">sx_api_fdb_mc_mac_addr_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mac_key_t *group_key, const sx_fdb_mac_data_t *data)</td></tr>
<tr class="separator:a03d816e7ed1c5915fb626d016831516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0c86ed51f1cd28c7ab51a8d49d6723"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5d0c86ed51f1cd28c7ab51a8d49d6723">sx_api_fdb_mc_mac_addr_group_get</a> (const sx_api_handle_t handle, const sx_fdb_mac_key_t *group_key, sx_fdb_mac_data_t *data_p)</td></tr>
<tr class="separator:a5d0c86ed51f1cd28c7ab51a8d49d6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af975d298e288b3700edb6bfa46ffe9e6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af975d298e288b3700edb6bfa46ffe9e6">sx_api_fdb_uc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:af975d298e288b3700edb6bfa46ffe9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607d3e59f86ea3030361a4d3ab11ca77"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a607d3e59f86ea3030361a4d3ab11ca77">sx_api_fdb_uc_flush_port_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port)</td></tr>
<tr class="separator:a607d3e59f86ea3030361a4d3ab11ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bda072a8e6c293b7ee18e106a0818f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af9bda072a8e6c293b7ee18e106a0818f">sx_api_fdb_uc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr class="separator:af9bda072a8e6c293b7ee18e106a0818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa694899ca36680e9e2fb2205831ed0fd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa694899ca36680e9e2fb2205831ed0fd">sx_api_fdb_uc_flush_port_fid_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fid_t fid)</td></tr>
<tr class="separator:aa694899ca36680e9e2fb2205831ed0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6731a3466288aedc59c1235f43c6820a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a6731a3466288aedc59c1235f43c6820a">sx_api_fdb_mc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a6731a3466288aedc59c1235f43c6820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c1584e35170d3ed04ef20904a57f6c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a39c1584e35170d3ed04ef20904a57f6c">sx_api_fdb_mc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr class="separator:a39c1584e35170d3ed04ef20904a57f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad302ac34a0c93901a8d71c84b830d55e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad302ac34a0c93901a8d71c84b830d55e">sx_api_fdb_fid_vlan_member_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)</td></tr>
<tr class="separator:ad302ac34a0c93901a8d71c84b830d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3021865defc7ae5cb76077cb049f910d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3021865defc7ae5cb76077cb049f910d">sx_api_fdb_global_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_ctrl_t learn_ctrl)</td></tr>
<tr class="separator:a3021865defc7ae5cb76077cb049f910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fc5b5032c1b055937b1b04f66def7c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af2fc5b5032c1b055937b1b04f66def7c">sx_api_fdb_global_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_ctrl_t *learn_ctrl_p)</td></tr>
<tr class="separator:af2fc5b5032c1b055937b1b04f66def7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adc069af59af3c899204cd18445b3f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af6adc069af59af3c899204cd18445b3f">sx_api_fdb_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:af6adc069af59af3c899204cd18445b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53851631fac831d1933522be461403"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a9b53851631fac831d1933522be461403">sx_api_fdb_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:a9b53851631fac831d1933522be461403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e05ca88a0204e228589ca94d28af1c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad8e05ca88a0204e228589ca94d28af1c">sx_api_fdb_fid_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:ad8e05ca88a0204e228589ca94d28af1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1228d15d780af59066b92bf2efd7d352"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1228d15d780af59066b92bf2efd7d352">sx_api_fdb_fid_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:a1228d15d780af59066b92bf2efd7d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635769f9f07a0d564566ca33ebd44884"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a635769f9f07a0d564566ca33ebd44884">sx_api_fdb_port_learn_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:a635769f9f07a0d564566ca33ebd44884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5156883cfdbcb9f246df889d0199eb7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa5156883cfdbcb9f246df889d0199eb7">sx_api_fdb_port_learn_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:aa5156883cfdbcb9f246df889d0199eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a51dd7cd5a11e51b9be1f25e62fd40a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a51dd7cd5a11e51b9be1f25e62fd40a">sx_api_fdb_notify_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr class="separator:a5a51dd7cd5a11e51b9be1f25e62fd40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8c246f21456f227318b5626ca7740"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab2b8c246f21456f227318b5626ca7740">sx_api_fdb_notify_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr class="separator:ab2b8c246f21456f227318b5626ca7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65caac4b1e478dbce337541fdfc046f2"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a65caac4b1e478dbce337541fdfc046f2">sx_api_fdb_flood_control_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, const uint16_t ports_count, const sx_port_log_id_t *const ports_list)</td></tr>
<tr class="separator:a65caac4b1e478dbce337541fdfc046f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a311aebd885a87ff66de06c452130dd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a311aebd885a87ff66de06c452130dd">sx_api_fdb_flood_control_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, uint16_t *const ports_count, sx_port_log_id_t *const ports_list)</td></tr>
<tr class="separator:a5a311aebd885a87ff66de06c452130dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34894776eebc52ed74b59b941f701c91"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a34894776eebc52ed74b59b941f701c91">sx_api_fdb_flood_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_mc_container_id_t flood_vector)</td></tr>
<tr class="separator:a34894776eebc52ed74b59b941f701c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23226433dadbbc949fc0a19f0254d7f9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a23226433dadbbc949fc0a19f0254d7f9">sx_api_fdb_flood_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_mc_container_id_t *flood_vector)</td></tr>
<tr class="separator:a23226433dadbbc949fc0a19f0254d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a16b9c750215270a1ffceb7d6e150"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a2e4a16b9c750215270a1ffceb7d6e150">sx_api_fdb_flood_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_flood_counters_t *const counters)</td></tr>
<tr class="separator:a2e4a16b9c750215270a1ffceb7d6e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61db615ac875ccce214e8600b86102c8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a61db615ac875ccce214e8600b86102c8">sx_api_fdb_flood_counter_clear</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a61db615ac875ccce214e8600b86102c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea4fb90301561b60d52be1e6d3d8199"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0ea4fb90301561b60d52be1e6d3d8199">sx_api_fdb_src_miss_protect_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t enable)</td></tr>
<tr class="separator:a0ea4fb90301561b60d52be1e6d3d8199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051ad00c09fa031624b47294adad966"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af051ad00c09fa031624b47294adad966">sx_api_fdb_src_miss_protect_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, boolean_t *enable_p)</td></tr>
<tr class="separator:af051ad00c09fa031624b47294adad966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e77d99c8a0a02143ab1b20d5a3fd3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aca4e77d99c8a0a02143ab1b20d5a3fd3">sx_api_fdb_src_miss_protect_drop_cntr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd)</td></tr>
<tr class="separator:aca4e77d99c8a0a02143ab1b20d5a3fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c7fe52e1a7a66bb116406820919e3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#acd8c7fe52e1a7a66bb116406820919e3">sx_api_fdb_src_miss_protect_drop_cntr_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, uint64_t *dropped_pkts_cntr)</td></tr>
<tr class="separator:acd8c7fe52e1a7a66bb116406820919e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b07aa93f3c82a70b451f5b9306b3f9b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1b07aa93f3c82a70b451f5b9306b3f9b">sx_api_fdb_igmpv3_state_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_fdb_igmpv3_state_t fdb_igmpv3_snooping_state)</td></tr>
<tr class="separator:a1b07aa93f3c82a70b451f5b9306b3f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b1f2b30e2c8b8065a1320779f84b7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ae79b1f2b30e2c8b8065a1320779f84b7">sx_api_fdb_igmpv3_state_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, sx_fdb_igmpv3_state_t *fdb_igmpv3_snooping_state)</td></tr>
<tr class="separator:ae79b1f2b30e2c8b8065a1320779f84b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b80e9d9cfc0540cf8be791423b881bf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7b80e9d9cfc0540cf8be791423b881bf">sx_api_fdb_mc_ip_addr_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *mc_fdb_mc_ip_key, const sx_fdb_mc_ip_action_t *fdb_mc_ip_action)</td></tr>
<tr class="separator:a7b80e9d9cfc0540cf8be791423b881bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f28553045fe213b7c86c9911a80689"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a29f28553045fe213b7c86c9911a80689">sx_api_fdb_mc_ip_addr_group_get</a> (const sx_api_handle_t handle, const sx_fdb_mc_ip_key_t *mc_fdb_mc_ip_key, sx_fdb_mc_ip_action_t *fdb_mc_ip_action_p)</td></tr>
<tr class="separator:a29f28553045fe213b7c86c9911a80689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dbdec283dc6a0e6aed34463e413eb7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a68dbdec283dc6a0e6aed34463e413eb7">sx_api_fdb_mc_ip_addr_group_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *key_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr class="separator:a68dbdec283dc6a0e6aed34463e413eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4027bd56cbce6623ad155c5ccd3bc11"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af4027bd56cbce6623ad155c5ccd3bc11">sx_api_fdb_mc_ip_addr_group_counter_bind_get</a> (const sx_api_handle_t handle, const sx_fdb_mc_ip_key_t *key_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr class="separator:af4027bd56cbce6623ad155c5ccd3bc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc956ac3e9e78a816f368f8104bdf7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a01cc956ac3e9e78a816f368f8104bdf7">sx_api_fdb_unreg_mc_flood_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_fdb_unreg_flood_mode_t urmc_flood_mode)</td></tr>
<tr class="separator:a01cc956ac3e9e78a816f368f8104bdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b47bb878ed5f257c93073c8e6a43f5"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a38b47bb878ed5f257c93073c8e6a43f5">sx_api_fdb_unreg_mc_flood_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_fdb_unreg_flood_mode_t *urmc_flood_mode_p)</td></tr>
<tr class="separator:a38b47bb878ed5f257c93073c8e6a43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3fbbd807c02081b6153fc89f759b3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ac8e3fbbd807c02081b6153fc89f759b3">sx_api_fdb_unreg_mc_flood_ports_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr class="separator:ac8e3fbbd807c02081b6153fc89f759b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94842d07542f4a835f7f9d78f1d9043"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ae94842d07542f4a835f7f9d78f1d9043">sx_api_fdb_unreg_mc_flood_ports_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr class="separator:ae94842d07542f4a835f7f9d78f1d9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaf604e293b33ce3ad10f9f078999df"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aceaf604e293b33ce3ad10f9f078999df">sx_api_fdb_mc_ip_addr_group_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *key_p, boolean_t *activity_p)</td></tr>
<tr class="separator:aceaf604e293b33ce3ad10f9f078999df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f9f71e8e65e1a8687080d39d4119ef"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a49f9f71e8e65e1a8687080d39d4119ef">sx_api_fdb_mc_ip_addr_group_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_filter_t *filter_p)</td></tr>
<tr class="separator:a49f9f71e8e65e1a8687080d39d4119ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa402a02c1b476045b0bdbfaf4d9e466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa402a02c1b476045b0bdbfaf4d9e466f">&#9670;&nbsp;</a></span>sx_api_fdb_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of FDB MODULE.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af69328504a7116dc2db6b42b18b13b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69328504a7116dc2db6b42b18b13b16">&#9670;&nbsp;</a></span>sx_api_fdb_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of FDB MODULE.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="acac719da53d4e58dc48ffc21dfce3460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac719da53d4e58dc48ffc21dfce3460">&#9670;&nbsp;</a></span>sx_api_fdb_age_time_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_age_time_t&#160;</td>
          <td class="paramname"><em>age_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">age_time</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a4396ebb8d79d5757b3f2df8b4ff3dd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4396ebb8d79d5757b3f2df8b4ff3dd51">&#9670;&nbsp;</a></span>sx_api_fdb_age_time_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_age_time_t *&#160;</td>
          <td class="paramname"><em>age_time_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">age_time_p</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a0c85bf694d723fc41318b9f41f801e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c85bf694d723fc41318b9f41f801e8a">&#9670;&nbsp;</a></span>sx_api_fdb_poll_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_poll_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB poll for MAC entries notifications.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no place in the jobs buffer </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a0fc878a321456849b437245a3889fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc878a321456849b437245a3889fa2d">&#9670;&nbsp;</a></span>sx_api_fdb_polling_interval_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_polling_interval_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB polling interval at 0.1 second granularity.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a53cad0c84e98f74c17ff84e111689b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cad0c84e98f74c17ff84e111689b3b">&#9670;&nbsp;</a></span>sx_api_fdb_polling_interval_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_polling_interval_t *&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the FDB polling interval in 0.1 second granularity.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a id="a463c7cb7c07a29ccba6f1bd5c56fc723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463c7cb7c07a29ccba6f1bd5c56fc723">&#9670;&nbsp;</a></span>sx_api_fdb_uc_mac_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes UC MAC and UC LAG MAC entries to/from the FDB. In case the operation fails on one entry (or more), an error is returned, mac_list_p stores those entries, and their quantity is stored in data_cnt. If the operation is completed successfully, SUCCESS is returned, and data_cnt_p and mac_list_p are not changed.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) or fid (filtering ID) in mac_list_p-&gt;fid_vid, you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_list_p</td><td>- list of MAC record parameters. Upon deletion, entry_type is DONT_CARE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of MAC records to ADD/DELETE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if the FDB hash bin is full </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab9d08fd9a8c2e68d0857b5ae986b5cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d08fd9a8c2e68d0857b5ae986b5cf5">&#9670;&nbsp;</a></span>sx_api_fdb_uc_mac_addr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_entry_type_t&#160;</td>
          <td class="paramname"><em>mac_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_key_filter_t *&#160;</td>
          <td class="paramname"><em>key_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads MAC entries from the SW FDB table, which is an exact copy of the HW DB on any device. The output supports up to SX_FDB_MAX_GET_ENTRIES entries whose default is 64.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) get information for current MAC + vlan - you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to 1. cmd should be SX_ACCESS_CMD_GET.</li>
<li>2) get a list of first n&lt;=64 MACs - data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GET_FIRST.</li>
<li>3) get a list of n&lt;=64 MACs which comes after certain MAC record (it does not have to exist) you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<p>mac_list_p returns the records info and their quantity in data_cnt_p for all types of requests.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) or fid (filtering ID) in key_p-&gt;fid_vid and fid in key_filter_p-&gt;fid, you should provide a bridge_id. bridge_id's will be stored in mac_list_p-&gt;fid_vid</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- get, get_next, get first </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_type</td><td>- static, dynamic, all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- MAC entry with information for search (MAC+FID) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_filter_p</td><td>- filter types used on the mac_list_p - FID/MAC/logical port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_list_p</td><td>- pointer to list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of entries to retrieve, also retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa216c40f7212a34ff4f48cdd514b7142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216c40f7212a34ff4f48cdd514b7142">&#9670;&nbsp;</a></span>sx_api_fdb_uc_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function counts all MAC entries in the SW FDB table (static and dynamic).</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ac844669ce5b39ebd0c54403b2ef31207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844669ce5b39ebd0c54403b2ef31207">&#9670;&nbsp;</a></span>sx_api_fdb_uc_port_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_port_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the amount of MACs learned on a port (static and dynamic).</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3c5e069db7cd02240336f1ddd556e507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5e069db7cd02240336f1ddd556e507">&#9670;&nbsp;</a></span>sx_api_fdb_uc_fid_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_fid_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the amount of MACs learned on an FID (static and dynamic).</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a7780abaea19956b6bd7a6738e81e5867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7780abaea19956b6bd7a6738e81e5867">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_port_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on a port.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a8649abe905403e7facd2edcad0f896a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8649abe905403e7facd2edcad0f896a1">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_port_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on a port.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a8e82f33acfac26987e66dd53dee91c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e82f33acfac26987e66dd53dee91c38">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID/FID/limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a760a24322ae990cad9789b7a579053db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760a24322ae990cad9789b7a579053db">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_fid_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on an FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO if message size is zero </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT if message size exceeds limit </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab5444b9e90b307936d49fe0c70232cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5444b9e90b307936d49fe0c70232cc9">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> This function adds/deletes MC MAC entries from the FDB.
 Note: MC entries cannot be created and associated with ports at the same time.

 Note: The log_port_list_p list should not contain the
        logical port items which are specified as an Ethernet
        port and which are members of a LAG port at same time.

 When the ADD command is requested this function performs the following:
 - checks a MC group is already created and returns FAILURE if yes;
 - allocates and stores the MC group;

 When the DELETE command is requested this function performs the following
 for each leaf device:
 - deletes MC FDB records
 - deletes FDB MC ID records
 - deletes SPGT record
 - deletes MC group from MCDB
 - returns pgi into the pool

 When Edit (add_port) command is requested this function performs
 the following:
 - updates the MC DB for adding logical ports and LAG ports
 - for each leaf device:
   - retrieves a list of LAG-member logical ports from LAGLib for
     all LAG logical ports which belong to this MC group
   - updates the SPGT record for adding the spine, MC members and
     LAGs member ports
   - adds local ports to FDB MC ID records (if FDB look-up
     by MC ID is allowed on leaf devices)

 When Edit (delete_port) command is requested this function performs
 the following:
 - updates MC DB for deleting logical ports and LAG ports
 - for each leaf device:
   - updates the SPGT record for deleting requested ports
     (if logical port is a LAG port then all LAG-member logical ports
     are removed);
   - removes local ports from FDB MC ID records
     (if FDB look up by MC ID is allowed on leaf devices)

 When in 802.1D mode, instead of providing a vid (Vlan ID),
 you should provide a bridge_id.

 Supported devices: Spectrum, Spectrum2.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete/add port/delete port/test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3640c0c7f4b5fb0112a6342872835131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3640c0c7f4b5fb0112a6342872835131">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves MC MAC entries data. NOTE: The log_port_list_p list contains LAG-port IDs only and does not contain LAG members' logical-port IDs.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3bfd50615d6d2455cec6ed2bb3305430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfd50615d6d2455cec6ed2bb3305430">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_mac_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mc_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves a list of one or more MC MAC keys (VLAN ID + MC MAC address). When in 802.1D mode, instead of providing a vid (VLAN ID) in key_p-&gt;vid and filter_p-&gt;vid, you should provide a bridge_id. In 802.1D mode, returned bridge_id's will be stored in key_list_p-&gt;vid. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, swid = valid, key = X, filter = valid/invalid, key_list = X key_cnt = 0: In this case the API will return the total number of MC MAC keys filtered by the filter parameter if present.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt = 1: The MC MAC key will be returned in the key_list along with a key_cnt of 1 in the following conditions: a) the key exists, a filter is provided and the key matches the filter b) the key exists, no filter is provided An empty list will be returned with key_cnt = 0 in the following conditions: a) the key doesn't exist b) the key exists, a filter is provided and the key doesn't match the filter A non-NULL key_list pointer must be provided in this case.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt &gt; 1: An key_cnt &gt; 1 will be treated as a key_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, swid = X, key = X, filter = X, key_list = NULL, key_cnt = 0: A zero key_cnt and an empty key_list will be returned.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, swid = valid, key = X, filter = valid/invalid, key_list = valid, key_cnt &gt; 0: In this case the API will return a list of MC MAC keys (max key_cnt) starting with first key of the internal DB and matching the filter if present. The input MC MAC key is ignored in this case. A non-NULL key_list pointer must be provided in this case.</li>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt &gt; 0: In this case the API will return a list of MC MAC keys (max key_cnt) starting with the next key after the input key and matching the filter if present. A non-NULL key_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- MC MAC key (VLAN ID + MC MAC address) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_list_p</td><td>- return list of MC MAC keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_cnt_p</td><td>- [in] number of MC MAC keys to get<ul>
<li>[out] number of MC MAC keys returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a03d816e7ed1c5915fb626d016831516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d816e7ed1c5915fb626d016831516a">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>group_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_data_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes MC MAC entries from the FDB. using multicast container as destination.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_key</td><td>- {fid, mac} key for multicast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- fdb data including action and mc container id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5d0c86ed51f1cd28c7ab51a8d49d6723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0c86ed51f1cd28c7ab51a8d49d6723">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>group_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mac_data_t *&#160;</td>
          <td class="paramname"><em>data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function get MC MAC entries from the FDB. using multicast container as destination.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_key</td><td>- {fid, mac} key for multicast </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- fdb data including action and mc container id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af975d298e288b3700edb6bfa46ffe9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af975d298e288b3700edb6bfa46ffe9e6">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_all_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB table entries on a switch partition. Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a607d3e59f86ea3030361a4d3ab11ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607d3e59f86ea3030361a4d3ab11ca77">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_port_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes the FDB table entries that are related to a flushed port.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af9bda072a8e6c293b7ee18e106a0818f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bda072a8e6c293b7ee18e106a0818f">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB table entries that were learned on the flushed FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa694899ca36680e9e2fb2205831ed0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa694899ca36680e9e2fb2205831ed0fd">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_port_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB table entries that were learned on the flushed FID and port.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a6731a3466288aedc59c1235f43c6820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6731a3466288aedc59c1235f43c6820a">&#9670;&nbsp;</a></span>sx_api_fdb_mc_flush_all_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB MC tables on a switch partition.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a39c1584e35170d3ed04ef20904a57f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c1584e35170d3ed04ef20904a57f6c">&#9670;&nbsp;</a></span>sx_api_fdb_mc_flush_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB MC table entries that were learned on the flushed FID on a switch partition.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ad302ac34a0c93901a8d71c84b830d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad302ac34a0c93901a8d71c84b830d55e">&#9670;&nbsp;</a></span>sx_api_fdb_fid_vlan_member_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_vlan_member_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function maps VLANs to filtering databases for shared VLAN learning (SVL) between VLANs. If independent VLAN learning is desired, a single VLAN should be mapped to a single FID.</p>
<p>When cmd=add This function adds FID to VID mapping record to the selected SWID. When cmd=delete This function deletes FID to VID mapping record from the selected SWID. The DEF_FID value is added to the corresponding VLAN.</p>
<p>NOTE: This API performs FDB flushing by FID before FID to VID mapping changing</p>
<p>NOTE: Only independent learning is supported in the current release.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<p>Supported devices: Not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3021865defc7ae5cb76077cb049f910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3021865defc7ae5cb76077cb049f910d">&#9670;&nbsp;</a></span>sx_api_fdb_global_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_ctrl_t&#160;</td>
          <td class="paramname"><em>learn_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the SWID's learning parameters into the system's DB.</p>
<p>NOTE: Only independent learning is supported in the current release.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch (virtual) ID (whose parameters to set) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_ctrl</td><td>- is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af2fc5b5032c1b055937b1b04f66def7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fc5b5032c1b055937b1b04f66def7c">&#9670;&nbsp;</a></span>sx_api_fdb_global_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_ctrl_t *&#160;</td>
          <td class="paramname"><em>learn_ctrl_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves the SWID's learning parameters from the system's DB.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch (virtual) ID (whose parameters to retrieve) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_ctrl_p</td><td>- Is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af6adc069af59af3c899204cd18445b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6adc069af59af3c899204cd18445b3f">&#9670;&nbsp;</a></span>sx_api_fdb_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB learning mode per SWID affecting all ports and VLANs in the SWID.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- new SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a9b53851631fac831d1933522be461403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b53851631fac831d1933522be461403">&#9670;&nbsp;</a></span>sx_api_fdb_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the FDB learning mode per SWID.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ad8e05ca88a0204e228589ca94d28af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e05ca88a0204e228589ca94d28af1c">&#9670;&nbsp;</a></span>sx_api_fdb_fid_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets FID's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a1228d15d780af59066b92bf2efd7d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1228d15d780af59066b92bf2efd7d352">&#9670;&nbsp;</a></span>sx_api_fdb_fid_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets fid's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a635769f9f07a0d564566ca33ebd44884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635769f9f07a0d564566ca33ebd44884">&#9670;&nbsp;</a></span>sx_api_fdb_port_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets port's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa5156883cfdbcb9f246df889d0199eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5156883cfdbcb9f246df889d0199eb7">&#9670;&nbsp;</a></span>sx_api_fdb_port_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets port's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5a51dd7cd5a11e51b9be1f25e62fd40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a51dd7cd5a11e51b9be1f25e62fd40a">&#9670;&nbsp;</a></span>sx_api_fdb_notify_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets FDB notify parameters. Note: Only takes effect when controlled learn mode is set.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_params_p</td><td>- new notify params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab2b8c246f21456f227318b5626ca7740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b8c246f21456f227318b5626ca7740">&#9670;&nbsp;</a></span>sx_api_fdb_notify_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets FDB notify parameters.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">notify_params_p</td><td>- swid's notify params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a65caac4b1e478dbce337541fdfc046f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65caac4b1e478dbce337541fdfc046f2">&#9670;&nbsp;</a></span>sx_api_fdb_flood_control_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to block ports from flooding of selected FID.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD_PORTS / DELETE_PORTS / DELETE_ALL_PORTS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_list</td><td>- Array of logical ports</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and cmd is not DELETE_ALL_PORTS </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED Command provided is not supported. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5a311aebd885a87ff66de06c452130dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a311aebd885a87ff66de06c452130dd">&#9670;&nbsp;</a></span>sx_api_fdb_flood_control_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve blocked ports from flooding of selected FID. ports count will be updated with the number of blocked ports. passing ports_count 0 and ports_list NULL, will return the number of ports in ports_count.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array, returned as number of actual ports </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ports_list</td><td>- (Optional) Array to fill blocked logical ports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and ports_count is not 0. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a34894776eebc52ed74b59b941f701c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34894776eebc52ed74b59b941f701c91">&#9670;&nbsp;</a></span>sx_api_fdb_flood_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_container_id_t&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage flood control for tunnels. Configuration from this API extends config from sx_api_fdb_flood_control_set for tunnel support. For each tunnel, you can add or remove flooding for specified bridge.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / DELETE / SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_vector</td><td>- MC Container contains Flooding vector as ecmp object for head replication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel or fid doesn't exists. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if fid already have flooding vector. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a23226433dadbbc949fc0a19f0254d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23226433dadbbc949fc0a19f0254d7f9">&#9670;&nbsp;</a></span>sx_api_fdb_flood_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_container_id_t *&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get flood control settings for a tunnel.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flood_vector</td><td>- MC Container contains Flooding vector as ecmp object for head replication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if flooding vector not set </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a2e4a16b9c750215270a1ffceb7d6e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a16b9c750215270a1ffceb7d6e150">&#9670;&nbsp;</a></span>sx_api_fdb_flood_counter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_counters_t *const&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve flooding counters of the switch.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>- counters struct to retrieve information to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command provided is not supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if counters is null </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a61db615ac875ccce214e8600b86102c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61db615ac875ccce214e8600b86102c8">&#9670;&nbsp;</a></span>sx_api_fdb_flood_counter_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_clear </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to clear flooding counters of the switch.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd></dl>

</div>
</div>
<a id="a0ea4fb90301561b60d52be1e6d3d8199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea4fb90301561b60d52be1e6d3d8199">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets port's fdb miss protect mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>- enable smac miss port protection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="af051ad00c09fa031624b47294adad966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af051ad00c09fa031624b47294adad966">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>enable_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets port's fdb miss protect mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enable_p</td><td>- port's fdb miss protection enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="aca4e77d99c8a0a02143ab1b20d5a3fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e77d99c8a0a02143ab1b20d5a3fd3">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_drop_cntr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets port's source miss protection drop counter.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="acd8c7fe52e1a7a66bb116406820919e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8c7fe52e1a7a66bb116406820919e3">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_drop_cntr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dropped_pkts_cntr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets port's source miss protection drop counter.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET / GET_AND_CLEAR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dropped_pkts_cntr</td><td>- port's source miss protection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO if SxD driver function fails </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="a1b07aa93f3c82a70b451f5b9306b3f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b07aa93f3c82a70b451f5b9306b3f9b">&#9670;&nbsp;</a></span>sx_api_fdb_igmpv3_state_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_igmpv3_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_igmpv3_state_t&#160;</td>
          <td class="paramname"><em>fdb_igmpv3_snooping_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function set the IGMP v3 state.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- Command: Set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_igmpv3_snooping_state</td><td>- Enable/ Disable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ae79b1f2b30e2c8b8065a1320779f84b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79b1f2b30e2c8b8065a1320779f84b7">&#9670;&nbsp;</a></span>sx_api_fdb_igmpv3_state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_igmpv3_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_igmpv3_state_t *&#160;</td>
          <td class="paramname"><em>fdb_igmpv3_snooping_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function get the IGMP v3 state.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- Command: Get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdb_igmpv3_snooping_state-</td><td>Pointer to the IGMP v3 state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a7b80e9d9cfc0540cf8be791423b881bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b80e9d9cfc0540cf8be791423b881bf">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>mc_fdb_mc_ip_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_action_t *&#160;</td>
          <td class="paramname"><em>fdb_mc_ip_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function set MC IP entries. using multicast container as destination.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete/delete_all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_fdb_mc_ip_key</td><td>- Structure contained the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_mc_ip_action</td><td>- Structure contained Action/Container ID/ Trap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a29f28553045fe213b7c86c9911a80689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f28553045fe213b7c86c9911a80689">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>mc_fdb_mc_ip_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mc_ip_action_t *&#160;</td>
          <td class="paramname"><em>fdb_mc_ip_action_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function get MC IP entries. using multicast container as destination.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_fdb_mc_ip_key</td><td>- Structure contained the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdb_mc_ip_action</td><td>- Pointer to a Structure contained Action/Container ID/ Trap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a68dbdec283dc6a0e6aed34463e413eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dbdec283dc6a0e6aed34463e413eb7">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function set bind counter to MC IP entry.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- Structure contained the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- Command: SX_ACCESS_CMD_ADD/SX_ACCESS_CMD_DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- counter id for adding/deleting from rule</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af4027bd56cbce6623ad155c5ccd3bc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4027bd56cbce6623ad155c5ccd3bc11">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function get bound counter to MC IP entry.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- Structure contained the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id</td><td>- Pinter to counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a01cc956ac3e9e78a816f368f8104bdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cc956ac3e9e78a816f368f8104bdf7">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_unreg_flood_mode_t&#160;</td>
          <td class="paramname"><em>urmc_flood_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets unregistered MC flood mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urmc_flood_mode</td><td>- unregistered MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a38b47bb878ed5f257c93073c8e6a43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b47bb878ed5f257c93073c8e6a43f5">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_unreg_flood_mode_t *&#160;</td>
          <td class="paramname"><em>urmc_flood_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves unregistered MC flood mode.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">urmc_flood_mode_p</td><td>- unregister MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ac8e3fbbd807c02081b6153fc89f759b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e3fbbd807c02081b6153fc89f759b3">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_ports_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_ports_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets unregistered MC flood ports.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port may be a LAG or physical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ae94842d07542f4a835f7f9d78f1d9043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94842d07542f4a835f7f9d78f1d9043">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_ports_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_ports_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves unregistered MC flood ports.</p>
<p>Supported devices: Spectrum, Spectrum2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port can be LAG or physical port </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aceaf604e293b33ce3ad10f9f078999df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaf604e293b33ce3ad10f9f078999df">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_activity_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads and clears multicast entry activity.</p>
<p>Supported devices: Spectrum, Spectrum2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_mc_key_p</td><td>- mc entry key {fid, source IP address, group address} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- activity state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a49f9f71e8e65e1a8687080d39d4119ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f9f71e8e65e1a8687080d39d4119ef">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_activity_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initiates a notification regarding active mc fdb entries in the system.</p>
<p>Supported devices: Spectrum, Spectrum2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 21:54:22 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
